抓取數量x的封包來源
sniff(count=x)

顯示各封包詳細資訊
a=_
a.summary()

抓取四個封包並顯示基本資訊
sniff(count=4, prn=lambda x: x.summary())

不間斷無限數抓取封包和其資訊
sniff(iface="com_name", prn=lambda x: x.summary())

顯示所有該封包詳細資訊
sniff(count=1, iface="com_name", prn=lambda x: x.show())

讀取pcap
p = rdpcap("檔案路徑.pcap")
再打一次p回傳封包種類數量

得到p的frame長度
len(p)

設定一參數為p內特定位置封包
pkt = p[10000]
再打一次pkt得到封包詳細資訊

得到pkt的frame種類
type(pkt)

得到pkt的所有userspace變數
dir(pkt)

顯示所有scapy可用的指令
lsc()

顯示pkt內的所有hexdump
hexdump(pkt)

顯示pkt內的所有field
ls(pkt)

顯示pkt的基本資訊
pkt.summary()

顯示pkt的詳細資訊
pkt.show()

建立IP封包
IP()

建立有TCP layer的IP封包
IP()/TCP()

建立有Ether frame和TCP layer的IP封包
Ether()/IP()/TCP()

建立有Ether frame, raw data和TCP layer的IP封包
Ether()/IP()/TCP()/"Here is the raw data"

可以在IP封包內建立一個IP layer,或將TCP改為UDP
Ether()/IP()/IP()/UDP()/"Here is the raw data"

指定IP的protocal為x
IP(proto=x)/TCP()

變數宣告IP封包
pck = IP()

設定封包位址
pck.dst = "127.0.0.1"
再打一次pck得到封包資訊

傳送封包
send(pck)

傳送protocol為ICMP並有raw data的封包
send(pck/ICMP()/"Here is the raw data")

設定變數為傳送封包
p = send(pck/ICMP()/"Here is the raw data", return_packets=True)
再打一次p得到封包資訊

顯示封包p的詳細資訊
p.show()

宣告為sendp(傳送封包)函式
p = sendp(Ether()/"this is ethernet", iface="com_name", return_packets=True)

傳送並接收一個位址為dst的封包(sr1函式)
p = sr1(IP(dst="192.168.0.0")/ICMP()/"abcde")
再打一次p得到封包資訊

dst也可設為網址
p = sr1(IP(dst="www.slashdot.org")/ICMP()/"abcde")

加入dns函式
p = sr1(IP(dst="8.8.8.8")/UDP()/DNS(rd=1,qd=DNSQR(qname="www.google")))

連續傳送封包函式(sr),dport為destination port(四個dport為傳收四個封包)
sr(IP(dst="192.168.0.0")/TCP(dport=[21,22,23,80]))

設定有和沒有收到答覆的變數
ans, unan = _

顯示收到答覆的資訊
ans.summary()

在ans資訊的迴圈內查看接收封包詳細資訊
for snd,rcv in ans:
    print(hexdump(rcv), rcv.show())

收送封包的loop函式(srloop),可用作send flooding(洪水攻擊)
srloop(IP(dst="www.google.com")/TCP(dport=80, flags="S"))

TCP內可指定source port
a, b = sr(IP(dst="www.google.com")/TCP(sport=[RandShort()*10]))

plot out傳送的封包的資訊
a.plot(lambda x: x[1].id)